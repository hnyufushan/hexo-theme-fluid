---
title: RequestBody和RequestParam区别全面详细
date: 2024-01-16 15:29:56
permalink: /pages/20001.html
categories: 
  - 编程世界
  - Java学习笔记
tags: 
  - null

description: 
---

RequestBody和RequestParam区别全面详细



### @RequestBody和@RequestParam区别全面详细
@RequestParam
> * 注解@RequestParam接收的参数是来自requestHeader中，即请求头。
>* RequestParam可以接受简单类型的属性，也可以接受对象类型。
>* @RequestParam有三个配置参数：
   required 表示是否必须，默认为 true，必须。
   defaultValue 可设置请求参数的默认值。
   value 为接收url的参数名（相当于key值）。
>* @RequestParam用来处理 Content-Type 为 application/x-www-form-urlencoded 编码的内容，Content-Type默认为该属性。@RequestParam也可用于其它类型的请求，例如：POST、DELETE等请求。
   所以在postman中，要选择body的类型为 x-www-form-urlencoded，这样在headers中就自动变为了 Content-Type : application/x-www-form-urlencoded 编码格式。
   但是这样不支持批量插入数据啊，如果改用 json 字符串来传值的话，类型设置为 application/json，点击发送的话，会报错，后台接收不到值，为 null。
   这时候，注解@RequestBody就派上用场了。继续往下看

### @RequestBody
> 注解@RequestBody接收的参数是来自requestBody中，即请求体。一般用于处理非 Content-Type: application/x-www-form-urlencoded编码格式的数据，比如：application/json、application/xml等类型的数据。
就application/json类型的数据而言，使用注解@RequestBody可以将body里面所有的json数据传到后端，后端再进行解析。
GET请求中，因为没有HttpEntity，所以@RequestBody并不适用。
POST请求中，通过HttpEntity传递的参数，必须要在请求头中声明数据的类型Content-Type，SpringMVC通过使用
HandlerAdapter 配置的HttpMessageConverters来解析HttpEntity中的数据，然后绑定到相应的bean上。

### 向表中批量插入数据
举个批量插入数据的例子，Controller层的写法如下图所示：
> 由于@RequestBody可用来处理 Content-Type 为 application/json 编码的内容，所以在postman中，选择body的类型为row -> JSON(application/json)，这样在 Headers 中也会自动变为 Content-Type : application/json 编码格式。body内的数据如下图所示：
批量向表中插入两条数据，这里的 saveBatchNovel()方法已经封装了 JPA的 saveAll() 方法。body 里面的 json 语句的 key 值要与后端实体类的属性一一对应。
注意：前端使用$.ajax的话，一定要指定 contentType: “application/json;charset=utf-8;”，默认为 application/x-www-form-urlencoded。

### 后端解析json数据
上述示例是传递到实体类中的具体写法，那么如果传递到非实体类中，body里面的json数据需要怎么解析呢？我们再来看下面这个例子：
在body中，我们还是输入上面的json数据，根据分析，上面的json数据是一个List数组内嵌套着map对象，那么在后台的接收形式可写为 List<Map<String, String>>，具体代码如下图所示：
> 得出结论，通过@RequestBody可以解析Body中json格式的数据。

### POST请求时
> @RequestBody --> JSON字符串部分
@RequestParam --> 请求参数部分
application/json格局图
form-data、x-www-form-urlencoded格局图

从content-type方面总结：
>① form-data、x-www-form-urlencoded：不可以用@RequestBody；可以用@RequestParam。见postman的格局，这两种方式的时候没有json字符串部分。
② application/json：json字符串部分可以用@RequestBody；url中的?后面参数可以用@RequestParam。见postman的格局

从两种注解方式总结：
@RequestBody
```java
(@RequestBody Map map)
(@RequestBody Object object)
application/json时候可用
form-data、x-www-form-urlencoded时候不可用
```
@RequestParam
```java
(@RequestParam Map map)
application/json时候，json字符串部分不可用，url中的?后面添加参数即可用，form-data、x-www-form-urlencoded时候可用，但是要将Headers里的Content-Type删掉
```
```java
(@RequestParam String waterEleId,@RequestParam String enterpriseName)
application/json时候，json字符串部分不可用，url中的?后面添加参数即可用
form-data、x-www-form-urlencoded时候可用，且参数可以没有顺序（即前端传过来的参数或者url中的参数顺序不必和后台接口中的参数顺序一致，只要字段名相同就可以），但是要将Headers里的Content-Type删掉
```
```java
(@RequestParam Object object)
不管application/json、form-data、x-www-form-urlencoded都不可用
```
既不是@RequestBody也不是@RequestParam，没有指定参数哪种接收方式
```java
(Map map)
(Object object)
application/json时候：json字符串部分不可用，url中的?后面添加参数不可用。
因为没有指定，它也不知道到底是用json字符串部分还是?后面添加参数部分，所以干脆都不可以用
form-data、x-www-form-urlencoded时都不可用，见图二

(HttpServletRequest request)
application/json不可用
form-data、x-www-form-urlencoded时可用
```
### GET请求
@RequestBody
```java
RequestBody -- Map / Object
GET请求中不可以使用@RequestBody
```
@RequestParam
```java
(@RequestParam Map map)
在url中的?后面添加参数即可使用
```
```java
(@RequestParam String waterEleId,@RequestParam String enterpriseName)
在url中的?后面添加参数即可使用
```
```java
(@RequestParam Object object)
GET请求中不可以使用
```
当使用GET请求时，通过postman添加?后面的参数，不用在url中自己一个一个拼，点击Params，在下面key-value中输入就自动拼接到url中
举列子
上传文件，包含了图中圈出来的两部分
如果这样，没有@RequestParam，那么url?后的参数就拿不到
```java
@RequestMapping(value = "/leadingIn", method = RequestMethod.POST)
    public ResponseObj<Boolean> leadingIn(Map formData,
                                          HttpServletRequest request,
                                          Map<String, InputStream> files) {
}
```
如果control中这样接收，本来想formData只接收url?后的参数，结果将{ “retCode”: null, “data”: true }这部分内容也拿到了，真实意外之喜。字符串这部分内容还可以从request中取到，见下面完整方法。
```java
@RequestMapping(value = "/leadingIn", method = RequestMethod.POST)
    public ResponseObj<Boolean> leadingIn(@RequestParam Map formData,
                                          HttpServletRequest request,
                                          Map<String, InputStream> files) {
}
```
完整方法
```java
/**
     * 导入
     */
    @RequestMapping(value = "/leadingIn", method = RequestMethod.POST)
    public ResponseObj<Boolean> leadingIn(@RequestParam Map formData,
                                          HttpServletRequest request,
                                          Map<String, InputStream> files) {
        //测试
        try {
            MultipartHttpServletRequest mulRequest = (MultipartHttpServletRequest) request;
            Set<Map.Entry<String, MultipartFile>> set = mulRequest.getFileMap().entrySet();
            Map<String, InputStream> listFile = new LinkedHashMap<>();
            System.out.println("个数" + set.size());
            for (Map.Entry<String, MultipartFile> each : set) {
                String fileName = each.getKey();
                MultipartFile file = each.getValue();
                //这里需要上传FTP
                try {
                    listFile.put(fileName, file.getInputStream());
                } catch (Exception ex) {
                    return new ResponseObj<>(false, null);
                }
            }

            String formjson = mulRequest.getParameter("content");
            ObjectMapper mapper = new ObjectMapper();
            mapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);
            mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

//            boolean result = iInstallWorkOrder.upLoadFile(listFile);
            boolean result = true;

            return new ResponseObj<>(result, null);
        } catch (Exception ex) {
            System.out.println(ex.toString());
            return new ResponseObj<>(false, null);
        }

    }
```
按F12看一下Network里对应请求：
使用@RequestParam：Content-Type为application/x-www-form-urlencoded，参数在FormData中
使用@RequestBody：Content-Type为application/json，参数在Request PayLoad中

### 总结
> 1.  在GET请求中，不能使用@RequestBody
> 2. 在POST请求，可以使用@RequestBody和@RequestParam，但是如果使用@RequestBody，对于参数转化             的配置必须统一。
> 3. 可以使用多个@RequestParam获取数据，@RequestBody不可以

标题举个例子11
>    在SpringMVC配置了HttpMessageConverters处理栈中，指定json转化的格式，如Date转成‘yyyy-MM-dd’,则参数接收对象包含的字段如果是Date类型，就只能让客户端传递年月日的格式，不能传时分秒。因为不同的接口，它的参数可能对时间参数有不同的格式要求，所以这样做会让客户端调用同事对参数的格式有点困惑，所以说扩展性不高。 如果使用@RequestParam来接受参数，可以在接受参数的model中设置@DateFormat指定所需要接受时间参数的格式。 另外，使用@RequestBody接受的参数是不会被Servlet转化统一放在request对象的Param参数集中，@RequestParam是可以的。 另外，还有一种应用场景，接口规范为resultful风格时，举个例子：如果要获取某个id下此条问题答案的查询次数的话，则后台就需要动态获取参数，其注解为@PathVariable，并且requestMapping中的value应为value="/{id}/queryNum"，

